package test

import (
	"math/rand"

	"github.com/nervosnetwork/ckb-sdk-go/v2/collector"
	"github.com/nervosnetwork/ckb-sdk-go/v2/types"
	"perun.network/perun-ckb-backend/backend/test"
)

type MockIterator struct {
	inputs   []*types.TransactionInput
	defaults []TransactionInputOpt
}

func (mi *MockIterator) HasNext() bool {
	return len(mi.inputs) != 0
}

func (mi *MockIterator) Next() *types.TransactionInput {
	ti := mi.inputs[0]
	mi.inputs = mi.inputs[1:]
	return ti
}

var _ collector.CellIterator = (*MockIterator)(nil)

func NewMockIterator(defaults ...TransactionInputOpt) *MockIterator {
	return &MockIterator{
		inputs:   []*types.TransactionInput{},
		defaults: defaults,
	}
}

type TransactionInputOpt func(*types.TransactionInput)

// GenerateInput generates a random transaction input using the given options.
// It makes sure that the resulting transaction input satisfies capacity
// constraints. The referenced input generated by this function will always at
// least contain as much capacity as is required for the cell and its
// referenced contents.
func (mi *MockIterator) GenerateInput(rng *rand.Rand, opts ...TransactionInputOpt) *MockIterator {
	typeScript := test.NewRandomScript(rng)
	lockScript := test.NewRandomScript(rng)
	ti := &types.TransactionInput{
		OutPoint: &types.OutPoint{
			TxHash: test.NewRandomHash(rng),
			Index:  rng.Uint32(),
		},
		Output: &types.CellOutput{
			Capacity: 0,
			Lock:     typeScript,
			Type:     lockScript,
		},
		OutputData: []byte{},
	}

	mi.applyDefaults(ti)

	for _, opt := range opts {
		opt(ti)
	}

	oc := ti.Output.OccupiedCapacity(ti.OutputData)
	if oc > ti.Output.Capacity {
		// Make sure we have enough capacity for the cell.
		ti.Output.Capacity = ti.Output.OccupiedCapacity(ti.OutputData)
	}
	mi.inputs = append(mi.inputs, ti)
	return mi
}

func (mi *MockIterator) applyDefaults(ti *types.TransactionInput) {
	for _, opt := range mi.defaults {
		opt(ti)
	}
}

func WithTypeScript(ts *types.Script) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.Output.Type = ts
	}
}

func WithLockScript(ts *types.Script) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.Output.Lock = ts
	}
}

func WithCapacityAtLeast(c uint64) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.Output.Capacity = c
	}
}

func WithData(d []byte) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.OutputData = d
	}
}

func WithHash(h types.Hash) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.OutPoint.TxHash = h
	}
}

func WithIndex(i uint32) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.OutPoint.Index = i
	}
}

func WithOutPoint(op *types.OutPoint) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.OutPoint = op
	}
}

func WithOutput(o *types.CellOutput) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.Output = o
	}
}
