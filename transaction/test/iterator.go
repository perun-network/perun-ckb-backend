package test

import (
	"math/rand"

	"github.com/nervosnetwork/ckb-sdk-go/v2/collector"
	"github.com/nervosnetwork/ckb-sdk-go/v2/types"
	"perun.network/perun-ckb-backend/backend/test"
)

type MockIterator struct {
	inputs   []*types.TransactionInput
	defaults []TransactionInputOpt
	idx      int
}

func (mi *MockIterator) HasNext() bool {
	return mi.idx < len(mi.inputs)
}

func (mi *MockIterator) Next() *types.TransactionInput {
	ti := mi.inputs[mi.idx]
	mi.idx++
	return ti
}

var _ collector.CellIterator = (*MockIterator)(nil)

func NewMockIterator(defaults ...TransactionInputOpt) *MockIterator {
	return &MockIterator{
		inputs:   []*types.TransactionInput{},
		defaults: defaults,
		idx:      0,
	}
}

type TransactionInputOpt func(*types.TransactionInput)

// GenerateInput generates a random transaction input using the given options.
// It makes sure that the resulting transaction input satisfies capacity
// constraints. The referenced input generated by this function will always at
// least contain as much capacity as is required for the cell and its
// referenced contents.
func (mi *MockIterator) GenerateInput(rng *rand.Rand, opts ...TransactionInputOpt) *MockIterator {
	typeScript := test.NewRandomScript(rng)
	lockScript := test.NewRandomScript(rng)
	ti := &types.TransactionInput{
		OutPoint: &types.OutPoint{
			TxHash: test.NewRandomHash(rng),
			Index:  rng.Uint32(),
		},
		Output: &types.CellOutput{
			Capacity: 0,
			Lock:     typeScript,
			Type:     lockScript,
		},
		OutputData: []byte{},
	}

	mi.applyDefaults(ti)

	for _, opt := range opts {
		opt(ti)
	}

	oc := ti.Output.OccupiedCapacity(ti.OutputData)
	if oc > ti.Output.Capacity {
		// Make sure we have enough capacity for the cell.
		ti.Output.Capacity = ti.Output.OccupiedCapacity(ti.OutputData)
	}
	mi.inputs = append(mi.inputs, ti)
	return mi
}

func (mi *MockIterator) GetInputs() []*types.TransactionInput {
	copyScript := func(s *types.Script) *types.Script {
		if s == nil {
			return nil
		}
		return &types.Script{
			CodeHash: s.CodeHash,
			HashType: s.HashType,
			Args:     s.Args,
		}
	}
	cloned := make([]*types.TransactionInput, len(mi.inputs))
	for i, ti := range mi.inputs {
		cloned[i] = &types.TransactionInput{
			OutPoint: &types.OutPoint{
				TxHash: ti.OutPoint.TxHash,
				Index:  ti.OutPoint.Index,
			},
			Output: &types.CellOutput{
				Capacity: ti.Output.Capacity,
				Lock:     copyScript(ti.Output.Lock),
				Type:     copyScript(ti.Output.Type),
			},
			OutputData: ti.OutputData,
		}
	}
	return cloned
}

func (mi *MockIterator) applyDefaults(ti *types.TransactionInput) {
	for _, opt := range mi.defaults {
		opt(ti)
	}
}

func WithTypeScript(ts *types.Script) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.Output.Type = ts
	}
}

func WithLockScript(ts *types.Script) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.Output.Lock = ts
	}
}

func WithCapacityAtLeast(c uint64) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.Output.Capacity = c
	}
}

func WithData(d []byte) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.OutputData = d
	}
}

func WithHash(h types.Hash) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.OutPoint.TxHash = h
	}
}

func WithIndex(i uint32) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.OutPoint.Index = i
	}
}

func WithOutPoint(op *types.OutPoint) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.OutPoint = op
	}
}

func WithOutput(o *types.CellOutput) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.Output = o
	}
}

func WithDataGenerator(dg func() []byte) TransactionInputOpt {
	return func(ti *types.TransactionInput) {
		ti.OutputData = dg()
	}
}
